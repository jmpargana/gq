
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>gq: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/jmpargana/gq/cmd/gq/main.go (0.0%)</option>
				
				<option value="file1">github.com/jmpargana/gq/internal/ast/ast.go (97.2%)</option>
				
				<option value="file2">github.com/jmpargana/gq/internal/ast/print.go (0.0%)</option>
				
				<option value="file3">github.com/jmpargana/gq/internal/gqjson/jsonparser.go (87.5%)</option>
				
				<option value="file4">github.com/jmpargana/gq/internal/gqjson/printer.go (0.0%)</option>
				
				<option value="file5">github.com/jmpargana/gq/internal/lexer/lexer.go (90.0%)</option>
				
				<option value="file6">github.com/jmpargana/gq/internal/parser/parser.go (88.1%)</option>
				
				<option value="file7">github.com/jmpargana/gq/internal/utils/types.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright Â© 2026 Joao Pargana jmpargana@gmail.com
*/
package main

import (
        "bufio"
        "fmt"
        "os"

        "github.com/jmpargana/gq/internal/ast"
        json "github.com/jmpargana/gq/internal/gqjson"
        "github.com/jmpargana/gq/internal/lexer"
        "github.com/jmpargana/gq/internal/parser"
        u "github.com/jmpargana/gq/internal/utils"
        "github.com/spf13/cobra"
)

var version = "dev"

var rootCmd = &amp;cobra.Command{
        Use:   "gq",
        Short: "jq-like command-line tool written in go",
        Long:  `A fast, simple, and expressive way to query and transform JSON data from the command line`,
        RunE: func(cmd *cobra.Command, _ []string) error <span class="cov0" title="0">{
                showVersion, _ := cmd.Flags().GetBool("version")
                if showVersion </span><span class="cov0" title="0">{
                        fmt.Printf("Version: %s\n", version)
                        os.Exit(0)
                }</span>

                <span class="cov0" title="0">if err := requireStdin(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no program provided")
                }</span>

                <span class="cov0" title="0">r := bufio.NewReader(os.Stdin)
                // TODO: replace with cobra args
                tokens := lexer.Lex(os.Args[1])
                p := parser.NewParser(tokens)

                t := p.ParseExpr()

                debug, _ := cmd.Flags().GetBool("debug")
                if debug </span><span class="cov0" title="0">{
                        fmt.Println("Generated AST:")
                        fmt.Println()
                        fmt.Println(ast.PrintAST(t, 0))
                }</span>

                <span class="cov0" title="0">obj := json.ParseObject(r)
                stream := u.NewStream()
                stream.O = append(stream.O, obj)
                result := ast.TransformStream(stream, t)
                for _, r := range result.O </span><span class="cov0" title="0">{
                        json.Print(r)
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}

func requireStdin() error <span class="cov0" title="0">{
        stat, err := os.Stdin.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stat stdin: %w", err)
        }</span>

        // If stdin is a terminal, nothing was piped
        <span class="cov0" title="0">if stat.Mode()&amp;os.ModeCharDevice != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no input provided on stdin")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() <span class="cov0" title="0">{
        err := rootCmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

func init() <span class="cov0" title="0">{
        // Here you will define your flags and configuration settings.
        // Cobra supports persistent flags, which, if defined here,
        // will be global for your application.

        // rootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "config file (default is $HOME/.tt.yaml)")

        // Cobra also supports local flags, which will only run
        // when this action is called directly.
        rootCmd.Flags().BoolP("version", "v", false, "Display CLI version")
        rootCmd.Flags().BoolP("debug", "d", false, "Displays AST from requested expression")
}</span>

func main() <span class="cov0" title="0">{
        Execute()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package ast

import (
        u "github.com/jmpargana/gq/internal/utils"
)

func TransformStream(s u.Stream, n u.Node) u.Stream <span class="cov10" title="36">{
        prev := s

        // prevent doubled indexing when creating dict
        if n.Value.Kind == u.ASSIGN </span><span class="cov5" title="7">{
                return prev
        }</span>

        <span class="cov9" title="29">for _, c := range n.Children </span><span class="cov8" title="17">{
                prev = TransformStream(prev, c)
        }</span>

        <span class="cov9" title="29">switch n.Value.Kind </span>{
        case u.IDX:<span class="cov8" title="18">
                prev = indexStream(prev, n.Value)</span>
        case u.INDEXSTART:<span class="cov2" title="2">
                arr := []any{}
                arr = append(arr, prev.O...)
                nextS := u.NewStream()
                nextS.O = append(nextS.O, arr)
                prev = nextS</span>
        case u.DICTSTART:<span class="cov5" title="5">
                prev = dictStream(prev, n)</span>
        }

        <span class="cov9" title="29">return prev</span>
}

func Transform(o any, n u.Node) any <span class="cov8" title="17">{
        prev := o

        // prevent doubled indexing when creating dict
        if n.Value.Kind == u.ASSIGN </span><span class="cov1" title="1">{
                return prev
        }</span>

        <span class="cov7" title="16">for _, c := range n.Children </span><span class="cov6" title="8">{
                prev = Transform(prev, c)
        }</span>

        <span class="cov7" title="16">switch n.Value.Kind </span>{
        case u.IDX:<span class="cov6" title="10">
                prev = index(prev, n.Value)</span>
        case u.INDEXSTART:<span class="cov3" title="3">
                prev = []any{prev}</span>
        case u.DICTSTART:<span class="cov1" title="1">
                prev = dict(prev, n)</span>
        }

        <span class="cov7" title="16">return prev</span>
}

func dict(o any, n u.Node) any <span class="cov1" title="1">{
        m := map[string]any{}
        for _, c := range n.Children </span><span class="cov1" title="1">{
                m[c.Value.Ident] = Transform(o, c.Children[0])
        }</span>
        <span class="cov1" title="1">return m</span>
}

// FIXME: add error handling
func index(o any, c u.Cmd) any <span class="cov6" title="10">{
        prev := o
        for _, f := range c.Fields </span><span class="cov8" title="23">{
                if f.Kind == u.IDX </span><span class="cov7" title="13">{
                        l := prev.([]any)
                        prev = l[f.Idx]
                }</span>
                <span class="cov8" title="23">if f.Kind == u.FIELD </span><span class="cov6" title="9">{
                        m := prev.(map[string]any)
                        prev = m[f.Name]
                }</span>
        }
        <span class="cov6" title="10">return prev</span>
}

func indexStream(s u.Stream, c u.Cmd) u.Stream <span class="cov8" title="18">{
        nextS := u.NewStream()
        for _, o := range s.O </span><span class="cov8" title="19">{
                prev := o

                for _, f := range c.Fields </span><span class="cov8" title="19">{
                        switch f.Kind </span>{
                        case u.IDX:<span class="cov0" title="0">
                                l := prev.([]any)
                                prev = l[f.Idx]</span>
                        case u.FIELD:<span class="cov4" title="4">
                                m := prev.(map[string]any)
                                prev = m[f.Name]</span>
                        case u.ARRAY:<span class="cov7" title="15">
                                l := prev.([]any)
                                nextS.O = append(nextS.O, l...)
                                return nextS</span>
                        }
                }

                <span class="cov4" title="4">nextS.O = append(nextS.O, prev)</span>
        }
        <span class="cov3" title="3">return nextS</span>
}

func cloneMap(m map[string]any) map[string]any <span class="cov7" title="16">{
        result := make(map[string]any)
        for k, v := range m </span><span class="cov5" title="6">{
                result[k] = v
        }</span>
        <span class="cov7" title="16">return result</span>
}

func dictStream(o u.Stream, n u.Node) u.Stream <span class="cov5" title="5">{
        nextS := u.NewStream()
        for _, s := range o.O </span><span class="cov6" title="8">{
                // cartesian product
                partials := []map[string]any{
                        {},
                }

                for _, c := range n.Children </span><span class="cov7" title="11">{

                        innerS := u.NewStream()
                        innerS.O = append(innerS.O, s)

                        innerS = TransformStream(innerS, c.Children[0])

                        var nextPartials []map[string]any

                        for _, p := range partials </span><span class="cov7" title="12">{
                                for _, in := range innerS.O </span><span class="cov7" title="16">{
                                        np := cloneMap(p)
                                        np[c.Value.Ident] = in
                                        nextPartials = append(nextPartials, np)
                                }</span>
                        }

                        <span class="cov7" title="11">partials = nextPartials</span>

                }

                <span class="cov6" title="8">for _, p := range partials </span><span class="cov7" title="12">{
                        nextS.O = append(nextS.O, p)
                }</span>
        }
        <span class="cov5" title="5">return nextS</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package ast

import (
        "fmt"
        "strings"

        u "github.com/jmpargana/gq/internal/utils"
)

func PrintAST(n u.Node, ident int) string <span class="cov0" title="0">{
        s := strings.Builder{}

        for i := 0; i &lt; ident; i++ </span><span class="cov0" title="0">{
                s.WriteRune(' ')
        }</span>

        <span class="cov0" title="0">s.WriteString(printCmd(n.Value, ident))
        // s.WriteRune('\n')

        for _, c := range n.Children </span><span class="cov0" title="0">{
                s.WriteString(PrintAST(c, ident+2))
        }</span>

        <span class="cov0" title="0">return s.String()</span>
}

func printCmd(c u.Cmd, ident int) string <span class="cov0" title="0">{
        s := strings.Builder{}

        switch c.Kind </span>{
        case u.ASSIGN:<span class="cov0" title="0">
                fmt.Fprintf(&amp;s, "ASSIGN: %s", c.Ident)</span>
        case u.ARRAY:<span class="cov0" title="0">
                fmt.Fprintf(&amp;s, "ARRAY:")</span>
        case u.DICTSTART:<span class="cov0" title="0">
                fmt.Fprintf(&amp;s, "DICT:")</span>
        case u.PIPE:<span class="cov0" title="0">
                fmt.Fprintf(&amp;s, "PIPE:")</span>
        case u.IDX:<span class="cov0" title="0">
                fmt.Fprintf(&amp;s, "IDX:")
                for _, f := range c.Fields </span><span class="cov0" title="0">{
                        s.WriteRune('\n')
                        for i := 0; i &lt; ident+2; i++ </span><span class="cov0" title="0">{
                                s.WriteRune(' ')
                        }</span>
                        <span class="cov0" title="0">switch f.Kind </span>{
                        case u.IDX:<span class="cov0" title="0">
                                fmt.Fprintf(&amp;s, "LIST: %d", f.Idx)</span>
                        case u.ROOT:<span class="cov0" title="0">
                                fmt.Fprintf(&amp;s, "ROOT")</span>
                        case u.ARRAY:<span class="cov0" title="0">
                                fmt.Fprintf(&amp;s, "ITER")</span>
                        case u.FIELD:<span class="cov0" title="0">
                                fmt.Fprintf(&amp;s, "FIELD: %s", f.Name)</span>
                        }
                }
        }

        <span class="cov0" title="0">s.WriteRune('\n')

        return s.String()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package gqjson

import (
        "bufio"
        "strconv"
        "strings"
)

func parseString(r *bufio.Reader) string <span class="cov6" title="28">{
        var sb strings.Builder
        var ignoreNext = false
        for </span><span class="cov8" title="56">{
                ch, _, err := r.ReadRune()
                if err != nil </span><span class="cov0" title="0">{
                        return sb.String()
                }</span>
                <span class="cov8" title="56">if ch == '\\' </span><span class="cov0" title="0">{
                        ignoreNext = true
                }</span>
                <span class="cov8" title="56">if ignoreNext </span><span class="cov0" title="0">{
                        ignoreNext = false
                        continue</span>
                }
                <span class="cov8" title="56">if ch == '"' </span><span class="cov6" title="28">{
                        return sb.String()
                }</span>
                <span class="cov6" title="28">sb.WriteRune(ch)</span>
        }
}

func parseNumber(ch rune, r *bufio.Reader) any <span class="cov7" title="49">{
        b := []byte{byte(ch)}
        for </span><span class="cov8" title="61">{
                next, err := r.Peek(1)
                if err != nil || next[0] == ',' || next[0] == '}' || next[0] == ']' </span><span class="cov7" title="49">{
                        break</span>
                }
                <span class="cov5" title="12">ch, err := r.ReadByte()
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov5" title="12">b = append(b, ch)</span>
        }

        <span class="cov7" title="49">for _, c := range b </span><span class="cov8" title="60">{
                if c == '.' || c == 'e' || c == 'E' </span><span class="cov1" title="1">{
                        f, _ := strconv.ParseFloat(string(b), 64)
                        return f
                }</span>
        }

        <span class="cov7" title="48">i, _ := strconv.ParseInt(string(b), 10, 64)
        return i</span>
}

func parseBool(ch rune, r *bufio.Reader) bool <span class="cov2" title="2">{
        out := false
        n := 4
        if ch == 't' </span><span class="cov2" title="2">{
                n = 3
                out = true
        }</span>
        <span class="cov2" title="2">for i := 0; i &lt; n; i++ </span><span class="cov4" title="6">{
                _, _, err := r.ReadRune()
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }
        <span class="cov2" title="2">return out</span>
}

func parseList(r *bufio.Reader) []any <span class="cov6" title="31">{
        out := []any{}
        for </span><span class="cov10" title="173">{
                ch, _, err := r.ReadRune()
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov10" title="173">switch ch </span>{
                case '{':<span class="cov4" title="9">
                        out = append(out, ParseObject(r))</span>
                case ',':<span class="cov7" title="37">
                        continue</span>
                case ']':<span class="cov6" title="31">
                        return out</span>
                case '[':<span class="cov5" title="10">
                        out = append(out, parseList(r))</span>
                case '"':<span class="cov1" title="1">
                        out = append(out, parseString(r))</span>
                case 't', 'f':<span class="cov1" title="1">
                        out = append(out, parseBool(ch, r))</span>
                case '1', '2', '3', '4', '5', '6', '7', '8', '9', '0':<span class="cov7" title="47">
                        out = append(out, parseNumber(ch, r))</span>
                }
        }
        <span class="cov0" title="0">return out</span>
}

func ParseObject(r *bufio.Reader) any <span class="cov6" title="28">{
        out := map[string]any{}
        ident := ""
        key := true
        pendingKey := ""
        for </span><span class="cov9" title="122">{
                ch, _, err := r.ReadRune()
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov9" title="122">switch ch </span>{
                case '[':<span class="cov6" title="21">
                        </span><span class="cov6" title="21">{
                                if pendingKey != "" </span><span class="cov4" title="9">{
                                        out[pendingKey] = parseList(r)
                                }</span> else<span class="cov5" title="12"> {
                                        return parseList(r)
                                }</span>
                        }
                case '{':<span class="cov4" title="7">
                        </span><span class="cov4" title="7">{
                                if pendingKey != "" </span><span class="cov1" title="1">{
                                        out[pendingKey] = ParseObject(r)
                                }</span>
                        }
                case '"':<span class="cov6" title="27">
                        </span><span class="cov6" title="27">{
                                ident = parseString(r)
                                if key </span><span class="cov6" title="20">{
                                        pendingKey = ident
                                }</span> else<span class="cov4" title="7"> {
                                        out[pendingKey] = ident
                                        pendingKey = ""
                                }</span>
                        }
                case ':':<span class="cov6" title="20">
                        </span><span class="cov6" title="20">{
                                key = false
                        }</span>
                case ',':<span class="cov3" title="4">
                        </span><span class="cov3" title="4">{
                                key = true
                        }</span>
                case 't', 'f':<span class="cov1" title="1">
                        </span><span class="cov1" title="1">{
                                out[pendingKey] = parseBool(ch, r)
                                pendingKey = ""
                        }</span>
                case '1', '2', '3', '4', '5', '6', '7', '8', '9', '0':<span class="cov2" title="2">
                        </span><span class="cov2" title="2">{
                                out[pendingKey] = parseNumber(ch, r)
                                pendingKey = ""
                        }</span>
                case ']':<span class="cov0" title="0">
                        return out</span>
                case '}':<span class="cov5" title="16">
                        return out</span>
                }
        }
        <span class="cov0" title="0">return out</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package gqjson

import "fmt"

const ident = 2

// FIXME: fix performance issue with string append
func printList(l []any, level int) string <span class="cov0" title="0">{
        s := "[\n"
        for i, it := range l </span><span class="cov0" title="0">{
                for range (level + 1) * ident </span><span class="cov0" title="0">{
                        s += " "
                }</span>
                <span class="cov0" title="0">switch it := it.(type) </span>{
                case string:<span class="cov0" title="0">
                        s += fmt.Sprintf("\"%s\"", it)</span>
                case int, int16, int32, int64, int8:<span class="cov0" title="0">
                        s += fmt.Sprintf("%d", it)</span>
                case float64, float32:<span class="cov0" title="0">
                        s += fmt.Sprintf("%f", it)</span>
                case bool:<span class="cov0" title="0">
                        s += fmt.Sprintf("%t", it)</span>
                case map[string]any:<span class="cov0" title="0">
                        s += printObj(it, level+1)</span>
                case []any:<span class="cov0" title="0">
                        s += printList(it, level+1)</span>
                }
                <span class="cov0" title="0">if i &lt; len(l)-1 </span><span class="cov0" title="0">{
                        s += ","
                }</span>
                <span class="cov0" title="0">s += "\n"</span>
        }
        <span class="cov0" title="0">for range level * ident </span><span class="cov0" title="0">{
                s += " "
        }</span>
        <span class="cov0" title="0">s += "]"
        return s</span>
}

func printObj(obj map[string]any, level int) string <span class="cov0" title="0">{
        s := ""
        s += "{\n"

        i := 0
        n := len(obj)

        for k, v := range obj </span><span class="cov0" title="0">{
                for range (level + 1) * ident </span><span class="cov0" title="0">{
                        s += " "
                }</span>
                <span class="cov0" title="0">s += fmt.Sprintf("\"%s\": ", k)
                switch v := v.(type) </span>{
                case string:<span class="cov0" title="0">
                        s += fmt.Sprintf("\"%s\"", v)</span>
                case int, int16, int32, int64, int8:<span class="cov0" title="0">
                        s += fmt.Sprintf("%d", v)</span>
                case float32, float64:<span class="cov0" title="0">
                        s += fmt.Sprintf("%.2f", v)</span>
                case bool:<span class="cov0" title="0">
                        s += fmt.Sprintf("%t", v)</span>
                case map[string]any:<span class="cov0" title="0">
                        s += printObj(v, level+1)</span>
                case []any:<span class="cov0" title="0">
                        s += printList(v, level+1)</span>
                }
                <span class="cov0" title="0">i++
                if i &lt; n </span><span class="cov0" title="0">{
                        s += ","
                }</span>
                <span class="cov0" title="0">s += "\n"</span>
        }

        <span class="cov0" title="0">for range level * ident </span><span class="cov0" title="0">{
                s += " "
        }</span>

        <span class="cov0" title="0">s += "}"
        return s</span>
}

// type token any
// TODO: refactor to token.String()
func Print(s any) <span class="cov0" title="0">{
        switch s := s.(type) </span>{
        case map[string]any:<span class="cov0" title="0">
                fmt.Println(printObj(s, 0))</span>
        case []any:<span class="cov0" title="0">
                fmt.Println(printList(s, 0))</span>
        case int64:<span class="cov0" title="0">
                fmt.Printf("%d\n", s)</span>
        case bool:<span class="cov0" title="0">
                fmt.Printf("%t\n", s)</span>
        case float64:<span class="cov0" title="0">
                fmt.Printf("%0.2f\n", s)</span>
        case string:<span class="cov0" title="0">
                fmt.Printf("\"%s\"\n", s)</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package lexer

import (
        "bufio"
        "strings"
        "unicode"
)

type TokenKind int

const (
        LBRACKET TokenKind = iota
        RBRACKET
        LBRACE
        RBRACE
        DOT
        PIPE
        COMMA
        COLON
        IDENT
        NUMBER
        STRING
        EOF
        ILLEGAL
)

type Token struct {
        Kind  TokenKind
        Value string
}

type Lexer struct {
        r   *bufio.Reader
        ch  rune
        eof bool
}

func Lex(s string) []Token <span class="cov0" title="0">{
        return lex(s)
}</span>

func lex(s string) []Token <span class="cov4" title="4">{
        l := newLexer(s)
        var tokens []Token
        for </span><span class="cov9" title="34">{
                tok := l.nextToken()
                tokens = append(tokens, tok)
                if tok.Kind == EOF </span><span class="cov4" title="4">{
                        break</span>
                }
        }
        <span class="cov4" title="4">return tokens</span>
}

func newLexer(s string) *Lexer <span class="cov4" title="4">{
        r := bufio.NewReader(strings.NewReader(s))
        ch, _, err := r.ReadRune()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;Lexer{
                        r:   r,
                        ch:  0,
                        eof: true,
                }
        }</span>
        <span class="cov4" title="4">return &amp;Lexer{
                r:   r,
                ch:  ch,
                eof: false,
        }</span>
}

func (l *Lexer) nextToken() Token <span class="cov9" title="34">{
        l.skipWhitespace()

        switch l.ch </span>{
        case 0:<span class="cov4" title="4">
                l.eof = true
                return Token{Kind: EOF}</span>
        case '.':<span class="cov5" title="7">
                l.read()
                return Token{Kind: DOT}</span>
        case ',':<span class="cov0" title="0">
                l.read()
                return Token{Kind: COMMA}</span>
        case ':':<span class="cov1" title="1">
                l.read()
                return Token{Kind: COLON}</span>
        case '|':<span class="cov1" title="1">
                l.read()
                return Token{Kind: PIPE}</span>
        case '{':<span class="cov1" title="1">
                l.read()
                return Token{Kind: LBRACKET}</span>
        case '}':<span class="cov1" title="1">
                l.read()
                return Token{Kind: RBRACKET}</span>
        case '[':<span class="cov5" title="6">
                l.read()
                return Token{Kind: LBRACE}</span>
        case ']':<span class="cov5" title="6">
                l.read()
                return Token{Kind: RBRACE}</span>
        default:<span class="cov5" title="7">
                if isDigit(l.ch) </span><span class="cov4" title="4">{
                        return l.readNumber()
                }</span>
                <span class="cov3" title="3">if isIdentStart(l.ch) </span><span class="cov2" title="2">{
                        return l.readIdent()
                }</span>
                <span class="cov1" title="1">if l.ch == '"' </span><span class="cov1" title="1">{
                        return l.readString()
                }</span>
                <span class="cov0" title="0">illegal := l.ch
                l.read()
                return Token{Kind: ILLEGAL, Value: string(illegal)}</span>
        }
}

func (l *Lexer) readNumber() Token <span class="cov4" title="4">{
        var b strings.Builder
        for isDigit(l.ch) </span><span class="cov4" title="4">{
                b.WriteRune(l.ch)
                l.read()
        }</span>
        <span class="cov4" title="4">return Token{Kind: NUMBER, Value: b.String()}</span>
}

func (l *Lexer) readString() Token <span class="cov1" title="1">{
        l.read() // skip "
        var b strings.Builder
        for l.ch != '"' &amp;&amp; l.ch != 0 </span><span class="cov1" title="1">{
                b.WriteRune(l.ch)
                l.read()
        }</span>
        <span class="cov1" title="1">l.read() // skip "
        return Token{Kind: STRING, Value: b.String()}</span>
}

func (l *Lexer) readIdent() Token <span class="cov2" title="2">{
        var b strings.Builder
        for isIdentChar(l.ch) </span><span class="cov2" title="2">{
                b.WriteRune(l.ch)
                l.read()
        }</span>
        <span class="cov2" title="2">return Token{Kind: IDENT, Value: b.String()}</span>
}

func (l *Lexer) read() <span class="cov10" title="37">{
        ch, _, err := l.r.ReadRune()
        if err != nil </span><span class="cov4" title="4">{
                l.ch = 0
                return
        }</span>
        <span class="cov9" title="33">l.ch = ch</span>
}

func (l *Lexer) skipWhitespace() <span class="cov9" title="34">{
        for l.ch == ' ' || l.ch == '\n' || l.ch == '\t' </span><span class="cov5" title="5">{
                l.read()
        }</span>
}

// TODO: move to utils
func isDigit(r rune) bool <span class="cov8" title="17">{
        return r &gt;= '0' &amp;&amp; r &lt;= '9'
}</span>

func isIdentStart(r rune) bool <span class="cov5" title="7">{
        return r == '_' || unicode.IsLetter(r)
}</span>

func isIdentChar(r rune) bool <span class="cov4" title="4">{
        return isIdentStart(r) || isDigit(r)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package parser

import (
        "strconv"

        "github.com/jmpargana/gq/internal/lexer"
        u "github.com/jmpargana/gq/internal/utils"
)

type Parser struct {
        ts  []lexer.Token
        pos int
}

func NewParser(cs []lexer.Token) *Parser <span class="cov5" title="20">{
        return &amp;Parser{ts: cs, pos: 0}
}</span>

func (p *Parser) peek() lexer.Token <span class="cov10" title="228">{
        return p.ts[p.pos]
}</span>

func (p *Parser) advance() lexer.Token <span class="cov9" title="125">{
        t := p.ts[p.pos]
        p.pos++
        return t
}</span>

func (p *Parser) match(kind lexer.TokenKind) bool <span class="cov7" title="59">{
        if p.pos &gt;= len(p.ts) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov7" title="59">if p.peek().Kind == kind </span><span class="cov6" title="21">{
                p.advance()
                return true
        }</span>
        <span class="cov7" title="38">return false</span>
}

func (p *Parser) expect(k lexer.TokenKind) lexer.Token <span class="cov7" title="59">{
        if p.peek().Kind == k </span><span class="cov7" title="59">{
                return p.advance()
        }</span>
        <span class="cov0" title="0">return lexer.Token{}</span>
}

func (p *Parser) ParseExpr() u.Node <span class="cov6" title="35">{
        term := p.parseTerm()

        for p.match(lexer.PIPE) </span><span class="cov4" title="7">{
                right := p.parseTerm()
                term = u.Node{Value: u.Cmd{Kind: u.PIPE}, Children: []u.Node{term, right}}
        }</span>

        <span class="cov6" title="35">return term</span>
}

func (p *Parser) parseTerm() u.Node <span class="cov7" title="42">{
        switch p.peek().Kind </span>{
        case lexer.DOT:<span class="cov6" title="31">
                return p.parseIndex()</span>
        case lexer.LBRACE:<span class="cov4" title="8">
                p.advance()
                expr := p.ParseExpr()
                p.expect(lexer.RBRACE)
                return u.Node{Value: u.Cmd{Kind: u.INDEXSTART}, Children: []u.Node{expr}}</span>
        case lexer.LBRACKET:<span class="cov2" title="3">
                return p.parseDict()</span>
        // FIXME:
        default:<span class="cov0" title="0">
                return u.Node{}</span>
        }
}

func (p *Parser) parseIndex() u.Node <span class="cov6" title="31">{
        idxs := []u.IdxField{}

        p.expect(lexer.DOT)
        for </span><span class="cov7" title="55">{
                tok := p.peek().Kind
                if !isValidIndexStarter(tok) </span><span class="cov6" title="31">{
                        if len(idxs) == 0 </span><span class="cov5" title="14">{
                                idxs = append(idxs, u.IdxField{Kind: u.ROOT})
                        }</span>
                        <span class="cov6" title="31">return u.Node{Value: u.Cmd{Kind: u.IDX, Fields: idxs}}</span>
                }

                <span class="cov6" title="24">switch tok </span>{
                case lexer.DOT:<span class="cov2" title="2">
                        p.advance()</span>
                case lexer.IDENT, lexer.STRING:<span class="cov4" title="9">
                        t := p.advance()
                        idxs = append(idxs, u.IdxField{Kind: u.FIELD, Name: t.Value})</span>
                case lexer.LBRACE:<span class="cov5" title="13">
                        p.advance()
                        switch p.peek().Kind </span>{
                        case lexer.RBRACE:<span class="cov2" title="3">
                                p.advance()
                                idxs = append(idxs, u.IdxField{Kind: u.ARRAY})</span>
                        case lexer.NUMBER:<span class="cov3" title="6">
                                t := p.advance()
                                n, err := strconv.Atoi(t.Value)
                                if err != nil </span><span class="cov0" title="0">{
                                        panic(err)</span>
                                }
                                <span class="cov3" title="6">if !p.match(lexer.RBRACE) </span><span class="cov0" title="0">{
                                        panic("need to close brace")</span>
                                }
                                <span class="cov3" title="6">idxs = append(idxs, u.IdxField{Kind: u.IDX, Idx: n})</span>
                        case lexer.IDENT, lexer.STRING:<span class="cov3" title="4">
                                t := p.advance()
                                if !p.match(lexer.RBRACE) </span><span class="cov0" title="0">{
                                        panic("need to close brace")</span>
                                }
                                <span class="cov3" title="4">idxs = append(idxs, u.IdxField{Kind: u.FIELD, Name: t.Value})</span>
                        // FIXME: break if not matching
                        default:<span class="cov0" title="0">
                                continue</span>
                        }
                // FIXME: break if not matching
                default:<span class="cov0" title="0">
                        continue</span>
                }
        }

}

func (p *Parser) parseDict() u.Node <span class="cov2" title="3">{
        p.expect(lexer.LBRACKET)
        assignments := []u.Node{}

        assignments = append(assignments, p.parseAssignment())

        for p.match(lexer.COMMA) </span><span class="cov3" title="4">{
                assignments = append(assignments, p.parseAssignment())
        }</span>

        <span class="cov2" title="3">p.expect(lexer.RBRACKET)

        return u.Node{Value: u.Cmd{Kind: u.DICTSTART}, Children: assignments}</span>
}

func (p *Parser) parseAssignment() u.Node <span class="cov4" title="7">{
        ident := p.expect(lexer.IDENT)
        p.expect(lexer.COLON)
        return u.Node{Value: u.Cmd{Kind: u.ASSIGN, Ident: ident.Value}, Children: []u.Node{p.ParseExpr()}}
}</span>

func isValidIndexStarter(t lexer.TokenKind) bool <span class="cov7" title="55">{
        return t == lexer.IDENT || t == lexer.STRING || t == lexer.LBRACE || t == lexer.DOT
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package utils

type Kind int

const (
        INDEXSTART = iota
        INDEXEND
        FIELD
        IDX
        PIPE
        DICTSTART
        DICTEND
        ASSIGN
        COMMA
        ROOT
        ARRAY
)

type Cmd struct {
        Kind   Kind
        Fields []IdxField
        Ident  string
}

type IdxField struct {
        Name string
        Idx  int
        Kind Kind
}

type Node struct {
        Value    Cmd
        Children []Node
}

type Stream struct {
        O []any
}

func NewStream() Stream <span class="cov10" title="44">{
        return Stream{
                O: []any{},
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
